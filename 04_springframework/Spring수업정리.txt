http://spring.io

1. Spring 개발 2가지 방법

  가. Spring Framework
     
      -XML 만 이용
      -XML + 어노테이션(@, 자바) : 최소한의 xml 필요
      -어노테이션(자바) : java Configuration

   ==> 개발자가 명시적으로 의존성 설정, 빈 등록, 의존성 주입, 서버설정 등 다양한 작업을 지정.

  나. SpringBoot
      - auto configuration
      - Spring Framework 어노테이션(자바) 기반


2. 빌드 툴(build tool)

  가. 개발 프로세스

  주문 --> 분석 --> 설계 ---> 구현 --->테스트 --> 패키지 ---> 배포

  나. 빌드 툴 
    - 개발 프로세스 자동화
    - 필요한 의존성 다운로드 설정기능
    - 자동으로 컴파일
    - 자동으로 테스트 ( 단위테스트 )
    - 자동으로 패키지 (압축, jar, war )
    - 자동으로 배포

  다. 종류
     - maven
        pom.xml 설정파일

     - gradle
        build.gradle 설정파일


3. Spring 특징

  가. POJO 기반
   - POJO ( Plain Old Java Object )
   - 클래스 작성시 어떠한 interface 또는 class 상속/구현하지 않음.

  나. 클래스
   - 빈(bean) 이라고 부름.
   - 직접 new 하지 않는다. ==> 외부에서 처리한다.
     a. 빈을 xml에 등록
         <bean id="" class="빈" />
     b. ApplicationContext에 xml 설정
       -ApplicationContext가 xml 정보를 보고 빈을 생성한다.

     c. 빈 사용
        - getBean("id값", 빈.class );


  다. 제어의 역행 ( Inversion of Control : IoC )
    - 빈을 생성 및 의존성 설정 작업을 직접하지 않고
      외부에서 처리하는 개념.
    - ApplicationContext가 IoC Container라고 한다.


  라. IoC Container 계층 구조

        BeanFactory   MessageSource
	     |          |  
	ApplicationContext ( 인터페이스 )
             |  
             |       
          WebApplicationContext(*, 웹환경)		
	  GenericXmlApplicationContext(*)
	  ClassPathXmlApplicationContext
	    ...


   마. 의존성 주입 ( dependency Injection : DI )
     - 외부에서 빈을 설정하는 개념

     a. 생성자 이용
        <bean>
	  <constructor-arg   value="">
          <constructor-arg   ref="">
     b. setter 메서드 이용
        <bean>
	  <property value="">
          <property ref="">

      - 주입받은 대상
          기본형, 문자열 : value 속성
	  클래스(참조형) : ref 속성
##################################################################
https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#beans-collection-elements
1. 1:n 의존성 주입 ==> Collection

  가. list
     - ArrayList
     - 순서있고 중복 가능
  나. set
     - HashSet
     - 순서없고 중복 불가
  다. map
     - HashMap
     - key/value 저장
     - key와 value 모두 object

  라. props
     - Properties
     - key/value 저장
     - key와 value 모두 String

2. util 태그 이용 - Collection
https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#appendix
   반드시 util namespace 설정
    가. list
      <util:list id="xxx">
		<ref bean="cat1" />
		<ref bean="cat2" />
		<ref bean="cat1" />
	</util:list>

    <bean id="service" class="com.service.UserService">
      <property name="list" >
        <ref bean="xxx"/>
      </property>
    </bean>

    나. set
     <!-- util -->
	<util:set id="xxx">
		<ref bean="cat1" />
		<ref bean="cat2" />
		<ref bean="cat1" />
	</util:set>
	<bean id="service" class="com.service.UserService">
		<property name="set">
		  <ref bean="xxx" />
		</property>
	</bean>

    다. map
    <util:map id="xxx">
		<entry key="c1" value-ref="cat1" />
		<entry key="c2">
			<ref bean="cat2" />
		</entry>
	</util:map>

	<bean id="service" class="com.service.UserService">
		<property name="map">
			<ref bean="xxx"/>
		</property>
	</bean>

    라.props



3. 빈 생성 관련되는 콜백 메서드

   가. 서블릿 
      - init() 메서드
      - doGet()/doPost() 메서드
      - destory() 메서드

   나. Spring
      a. <bean id="" class=""  init-method="메서드명" destroy-method="메서드명" >
      b. interface 이용

         - implments InitializingBean, DisposalBean{
	       // 추상메서드 재정의
	   }
      c. 어노테이션 이용
         - JDK 11 지원 불가 ( JDK 8 지원됨 )
         - 어노테이션 활성화 작업 필요: <context:annotation-config />
         - @PostConstruct
	  pulic void xxx(){}
	 - @PreDestroy
	  pulic void yyy(){}

4. profile
  - profile값에 따라서 개발환경을 다양하게 구축 가능.

  - 구성
   가. 개발환경
       - user-dev.xml
       - UserServiceDev.java

   나. 배포환경
       - user-prod.xml
       - UserServiceProd.java


               UserService (인터페이스)
	           |
    UserServiceDev    UserServiceProd

    
    설정방법:
    	GenericXmlApplicationContext ctx = 
				new GenericXmlApplicationContext();
		
	//profile 설정
	ctx.getEnvironment().setActiveProfiles("prod");  //dev, prod
	ctx.load("classpath:user-dev.xml", "classpath:user-prod.xml");
	ctx.refresh();


5. jdbc.properties에 설정된 환경설정값을 빈에 주입해서 사용하기

   가. src/main/resource에 jdbc.properties 작성

   나. xml에 jdbc.properties 파일 등록
      <!-- jdbc.properties 등록 -->
      <context:property-placeholder location="classpath:com/config/jdbc.properties"/>
     
   다. 빈에 주입
      - ${key}


6. I18N ( 국제화: InternationalizatioN )
  https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#context-functionality-messagesource
    가. 리소스번들 파일 작성
      문법: 파일명_국가별언어코드.properties
      src/main/resource에 저장
      greeting_ko.properties
      greeting_en.properties


    나. 리소스번들 등록 ( 주의할 점은 id값은 반드시 messageSource 로 설정해야 된다. )
   <bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource">
     <property name="basename" value="classpath:com/config/greeting" />
     <!--  properties 파일 인코딩을 utf-8로 지정한 경우 -->
     <property name="defaultEncoding" value="utf-8" />
   </bean>

   
    다. 사용

      a. TestMain에서 사용 가능
         	 MessageSource resources = 
				 new ClassPathXmlApplicationContext("classpath:com/config/user.xml");
		 String message = resources.getMessage("greet", new String[]{"홍길동","!!!"}, "Default", Locale.KOREA);
		 System.out.println(message);

      b. TestMain가 아닌 임의의 빈에서 사용 가능
         public class UserService implements MessageSourceAware{
	
	MessageSource resources;

	@Override
	public void setMessageSource(MessageSource messageSource) {
		this.resources = messageSource;
	}
      c. jsp에서 사용 가능


7. 빈의 scope

  - scope="prototype|singleton|request|session"

   ==> request|session 는 웹 환경에서 사용
       singleton 는 기본값이고 모든 빈을 하나만 생성해서 서비스됨.
       prototype 은 빈을 매번 새로 생성해서 서비스됨.


#########################################################
최소한의xml + 어노테이션 기반 어플리케이션 개발
==> 반드시 어노테이션을 활성화 작업이 필요.
    	<!-- 어노테이션 활성화 -->
	<context:annotation-config />

1) @Autowired ( byType 방법 이용 )
  - 기본적으로 일치하는 타입을 찾아서 자동으로 주입 ( <constructor-arg> 또는 <property> 지정안함 )
  - 지정위치 3군데
     a.변수 (권장)
     b.생성자
     c.set메서드

   - 주입할 대상이 없으면 NoSuchDefinitionException  발생됨. ==> 필수적으로 주입해야 된다.
     옵션으로 변경 가능 @Autowired(required=false)

   - 주입할 대상이 2개 이상이면 NoUniqueBeanDefinitionException 발생됨.
     a.명시적으로 지정 가능
       @Autowired
       @Qualifier(빈이름)

     b. 주입할 빈의 이름(id)값과 변수명 일치

        <bean id="yyy" class="com.dao.DeptDAO"></bean>

	@Autowired
	DeptDAO yyy;


2) @Resource ( byName 방법 이용 )
   - 기본적으로 일치하는 이름을 찾아서 자동으로 주입 ( <constructor-arg> 또는 <property> 지정안함 )
   - javax.annotation.Resource 패키지가 필요.
     <!-- https://mvnrepository.com/artifact/javax.annotation/javax.annotation-api -->
	<dependency>
	    <groupId>javax.annotation</groupId>
	    <artifactId>javax.annotation-api</artifactId>
	    <version>1.3.2</version>
	</dependency>

   -문법:
       @Resource (name="빈이름(id)")
  

3) @Value 
  - properties 파일에서 직접 빈의 변수에 주입해서 사용된다.

   가. src/main/resource에 jdbc.properties 작성

   나. xml에 jdbc.properties 파일 등록
      <!-- jdbc.properties 등록 -->
      <context:property-placeholder location="classpath:com/config/jdbc.properties"/>

   다. 빈에서 직접 사용

       @Value("${key}")
       String driver;
###########################################################
AOP ( Aspect Oriented Programming : 관점 지향 프로그래밍 )

1. 개요
   - 코드의 필수기능과 부가기능을 분리해서 개발하자
   -용어
   가. target: 실제 필수기능 구현된 빈
   나. aspect: 부가 기능 구현된 빈
       -@Aspect 어노테이션 지정

   다. joinpoint
       - target에 aspect가 삽입(위빙:weaving)되는 시점
       - 원천 기술 AOP: 다양한 시점에 위빙 가능 ( 예> 생성, 메서드 호출, 변수 변경,.... )
       - Spring AOP: 메서드 호출만 지원

   라. pointcut
        - 어떤 메서드 호출했을 때 위빙할것인지를 지정
	- 다양한 표현기술로 사용.
https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#aop-pointcuts-examples
   마. advice
        - 5가지 advice 제공

2. 설정

  가. 의존성 추가
    <!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver -->
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.21</version>
</dependency>


  나. 타겟 클래스 작성 ( 핵심기능이 구현된 빈 )
     UserService.java
            public String sayHello() {}

  다. aspect 클래스 작성 ( 부가 기능 구현된 빈 )
     UserServiceAspect.java


     @Aspect
    public class UserServiceAspect {


  라. aspect 클래스에 pointcut 지정

     @Pointcut("execution(메서드 정보 지정)" )
     public void 임의메서드(){}

  ==>  @Pointcut("execution(public String sayHello)" )
        public void xxx(){}


  마. 메서드 호출 전/후/정상종료/예외발생/모두 중에서 어느 시점에 위빙될지 결정 ( advice 라고 부른다. )

     a. 핵심기능 메서드 호출전(before advice )에 실행됨.
     
       @Before("xxx()") // @Pointcut의 메서드 지정
        public void method(){
           // 실제 부가 기능 코드 구현
	}

  바. 핵심빈, 부가빈을 user.xml 등록

  사. @Aspect 활성화
     - <aop:aspectj-autoproxy />
########################################################
1) 빈을 생성할때 XML 등록없이 사용하는 방법

  가. 빈 생성
  나. 최소한의 XML코드
     - 빈이 정의된 패키지명을 알려준다.
     <component-scan basepackage="패키지명" />

    예> com.service.UserService.java

      이전방식: user.xml
         
	    <bean id="service" class="com.service.UserService" />

      scan방식: user.xml

             <component-scan basepackage="com.service" />

   다. 반드시 지정된 패키지안에 마킹(어노테이션)된 빈들만 생성된다.

       - @Component
       - @Service
       - @Repository
       - @Controller
       - @RestController
       - @Configuration
