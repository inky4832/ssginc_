스프링 부트 (spring boot )

1. 환경설정

  - JDK 11
  - springboot 2.7.8  ( 2.6 기점으로 많이 변경 )
  - sts 3.9.14
  - mysql + mybatis

2. boot프로젝트 생성

   가. 웹사이트 이용 ( initializer 이용 )
  
       https://start.spring.io

       자바, 서블릿/jsp, springframe
         - 비웹환경: jar
	 - 웹환경:  war 

       springboot
         - jar ( 웹환경인 경우 war 가능 )
           웹을 jar로 실행가능한 이유가 tomcat을 내장이 가능하다.

        initializer 정보지정하고 Generate 버튼 선택하면 다운로드 됨. ( demo.zip )
	workspace에 복사하고 압축해제.
	sts에서 import > maven > existing maven project > workspace에서 demo 폴더선택 > finish

   나. sts에서 로컬 이용

        file > new > spring starter project 선택

        * 기존 spring framework은 spring legacy project 선택.


3. boot 프로젝트 구조

    가. spring framework
	- 필요한 의존성을 개별적으로 설정했음.
	 예> DB 연동시 최소한 5개의 의존성 설정 ==> 거의 모두 필요한 의존성들이다.

    나. springboot
        - 거의 필요한 의존성 파일들을 묶어서 제공 ==> starter 개념이다.


    다. boot 기본적인 의존성

                <dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter</artifactId>  ==> 비 웹 어플리케이션 개발용
			<artifactId>spring-boot-starter-web</artifactId>  ==> 웹 어플리케이션 개발용 (tomcat내장설치됨, jackson 포함,.... )
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>

     라. src/main/java
        ==> 프로젝트 생성시 자동으로 생성해주는 빈
	==> 웹 및 비웹 환경에서 무조건 있어야 된다.
            이유는 시작점이다.
	==> 웹 어플리케이션이라도 jar 배포가 가능한 이유이다.

	@SpringBootApplication
	public class DemoApplication {

		public static void main(String[] args) {
			SpringApplication.run(DemoApplication.class, args);
		}

	}
        
	* @SpringBootApplication 는 다음과 같은   3가지 어노테이션을 포함한다. 

	  @SpringBootConfiguration ==> 추가적인 configuration 설정이 가능 ( 이전 프레임워크에서 멀티 xml 사용한 방식과 유사 )
	                               @Configuration 으로 추가 configuration 지정이 가능.
	  @EnableAutoConfiguration ==> starter-xxx 지정하면 거의 자동으로 configuration 설정된다.
	  @ComponentScan ==> 자동으로 빈생성 ( 프레임워크의 <context:component-scan> 동일 기능 )
                           앞으로 생성할 빈들은 반드시 XXXApplication 이 가진 패키지의 하위 패키지로 만들어야 
			   자동으로 scan되어 생성될 수 있다.
			   예> com.example.dao
			       com.example.controller
			       ..

    마. xml 지원 안함.
       - 이전 프레임워크에서는 xml에 설정정보를 설정했음.
       - boot에서는 src/main/resource 의 application.properties 대신한다.
       - application.properties 대신에 application.yml 사용 가능 ( yml을 '야물' 파일이라고 부른다. )

         application.properties 사용
	 예> key.key2.key3=값
	     key.xxx.yyy=값

          pplication.yml 사용
	 예> key:
	       key2:
	          key3:값
               xxx:
	          yyy:값

     바. boot 프로젝트 실행

          Run as > Spring Boot App 선택

#####################################################################################################

문법 정리

1. 빈 생성 ( boot 문서의 권장방법 )
  ==> 앞으로 생성할 빈들은 반드시 XXXApplication 이 가진 패키지의 하위 패키지로 만든다.

   com.example.
               XXXApplication ( main, @SpringBootApplication)
	       .service
	           -*.java ( @Sevice )
	        .dao
		   -*.java ( @Repository )

2. 의존성 설정 ( DI )

    가. @Autowired

    나. 생성자 이용 
      - 주입할 데이터타입을 파라미터로 가진 생성자 이용한다.
      - 프레임워크에서도 사용 가능 ( 4.3 이후 )
      - 기본생성자를 지정하면 안됨.(*****)

3. 생성된 빈 조회 방법

          ApplicationContext ctx	
	       = SpringApplication.run(DemoApplication.class, args);
	  
	  DeptServiceImpl service = ctx.getBean("xxx", DeptServiceImpl.class);
	  System.out.println(service.getMesg());

4. I18N
  - 다국어 구현
  가. 번들 파일 작성
   src/main/resource
     message폴더
      greeting-en.properties
      greeting-ko.properties
      greeting.properties ( 기본값, 필수 )
   
   나. application.properties 등록 ( 프레임워크에서는 xml에 등록 )

       spring.messages.basename=message/greeting
	spring.messages.encoding=utf-8
       spring.messages.fallback-to-system-locale=false

       true 지정: 시스템의 로케일을 따른다. ( 현재 PC 국가별 설정을 따른다. )
       false 지정: 기본 properties를 따른다.

   
    다. 사용.

       BeanFactory    MessageSource
           |            | 
	ApplicationContext 
	     |
	 GenericXmlApplicationContext
	 WebApplicationContext
          ..
      
         a. main메서드 가진 Application 에서 사용
            ApplicationContext ctx =SpringApplication.run(DemoApplication.class, args);
			
		  String mesg = ctx.getMessage("greet", 
				  new String[] {"하이~","~~~"},  Locale.CHINA);
		  System.out.println(mesg);

         b. 임의의 빈에서 사용

               @Autowird
	       MessageSource ctx;

	    * 프레임워크에서는  implements MessageSourceAware 하고 
		    @Override
		public void setMessageSource(MessageSource messageSource) {
			this.resources = messageSource;
		}

5. AOP ( Aspect Oriented Programming , 관점지향 프로그래밍 )
  1) 개념: 필수기능과 부가기능을 분리해서 필요할 때 부가기능을 주입 받아서 사용하자.

  2) 용어
     - 타겟파일: 필수기능을 구현한 빈
     - aspect: 부가기능을 구현한 빈
     - joinpoint: 부가기능(aspect)이 필수기능(target)에 주입하는 시점의미.
                  Spring에서는 메서드 호출 시점만 가능하다.
                  AOP 원천기술은 Spring 이전 기술로서 다양한 주입 시점이 있다.
		  (예> 메서드 호출시점, 객체생성시점, 변수값 변경시점,..... )

     - pointcut : 어떤 메서드 호출시 주입할 것인지 표현하는 표현식 의미.
     - advice   : 메서드 호출전: before advice
                        호출후: after advice
			정상실행후결과값리턴후: after returning advice
			예외발생후         : after throwing advice
			또는 4가지모두      : around advice

  3) AOP 의존성 설정
     
      *프레임워크  버전
        <dependency>
	    <groupId>org.aspectj</groupId>
	    <artifactId>aspectjweaver</artifactId>
	    <version>1.9.21</version>
	</dependency>
  
       * boot 버전 - starter로 제공
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-aop</artifactId>
	</dependency>

  4) AOP 활성화

      가. 프레임워크
          <!--  AOP 활성화 -->	
           <aop:aspectj-autoproxy />

      나. boot ( 자동활성화 )
         application.properties에서 비활성화 가능
	 spring.aop.auto=false  ( 기본: true )