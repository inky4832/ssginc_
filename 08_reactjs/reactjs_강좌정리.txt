reactjs 강좌정리

1. 환경설정

  가.node.js설치
  나.vsc 설치
  다. vsc 확장팩
    - live server
    - reactjs code snippets (클래스기반)
    - reactjs snippets  ( 함수기반 )

  라. 크롬 브라우저에 React 플러그인 설치
      react developer tools

  

2. 리액트 개요

   가. client side rendering ( CSR )
      - 일반적으로 말하는 reactjs
      - http://ko.reactjs.org
	
   나. server  side rendering ( SSR )
      - next.js 라고 부른다.
      - https://react.dev

3. 리액트 특징
   - facebook에서 제공
   - 가상 DOM을 이용해서 빠른 DOM 조작이 가능
   - JSX 로 화면을 정의 ( html과 비슷 )
     ==> JSX는 나중에 html로 변환되어 처리됨
   - SPA ( Single Page Applicatio ) 최적화.
     ==> 미리 서버에서 하나의 index.html 파일을 다운받음.
         index.html 파일에 보여줄 수 있는 화면을 모두 포함함.
	 쪼개서 화면을 보여주는 방식이고 필요한 데이터는 서버에서 JSON 받아서 보여준다.
	 반대개념은 MPA ( Multiple Page Application)로서
	 필요할 때 서버에서 화면을 받아서 보여줌.

4. 개발 방법

   가. CDN 방식
      - 필요한 js 파일을 네트워크로 링크 지정해서 개발방법

   나. tool chain 방식 (*)
      - 도구 이용

5. React Tool Chain 방식으로 개발 방법

   가. 프로젝트 생성
      npx create-react-app 프로젝트명
     
     예> npx create-react-app my-app
        cd my-app  
        npm start open
       => http://localhost:3000/ 요청해서 화면에 랜더링 됨

   나. my-app 프로젝트 구조

      public/index.html  ==> 메인 홈페이지 화면
                             src/index.js 랜더링 해줌.
      public 폴더: 외부에서 그냥 접근 가능.

      src/index.js  : 시작점. <App /> 컴포넌트를 로딩해서 id="root"에 랜더링 됨.
      src/App.js    : 리액트의 함수 컴포넌트
                      컴포넌트의 화면을 구성하는 블럭이다.

       package.json  : nodejs의 모듈 관리 설정 파일
                      ( maven의 pom.xml 역할 )

6.컴포넌트(Component) 개요

  가. 개념
  - 웹화면에서 보여지는 화면 블럭을 의미한다. ( 서블릿버전의 top.jsp 또는 menu.jsp )
  - html과 비슷한 JSX 로 작성된다. ( JSX는 나중에 html로 변환됨 )
  - html과 비슷하게 중첩해서 작성한다. ( 컴포넌트 중첩 )

  나. 컴포넌트 생성 방법 2가지

    a. 클래스 컴포넌트
       - extends React.Component
       - render() 메서드 구현
       - return ( JSX코드 )
       - export 컴포넌트명

    b. 함수형 컴포넌트 (*****)
       - function 함수명(){}
         ==> 반드시 클래스처럼 함수명의 첫글자는 대문자로 지정해야 된다.
	    이유는 컴포넌트를 화면에 보여줄 때 <함수명 /> 태그형식으로 보여준다.
	    일반적인 html 태그와 구별하기 위해서 첫글자는 대문자로 지정한다.
	     예> <form> 과 <Form>
	        <form>은 html태그고
		<Form>은 함수형 컴포넌트이다.
        - return( JSX 코드 )
	- export 함수명 또는 export default 함수명
     
       ==> 화면에 보여주기 위해서는 일반적으로 사용하는  함수명() 형식이 아니고
           반드시 태그형태로 사용해야 된다. =>  <함수명 />
  
  ############################################
  실습 src_01_컴포넌트작성_기본
      src_01_컴포넌트작성2_외부파일로작성
   ############################################

7. 컴포넌트 리턴값

   1) JSX 반환
   2) 일반 데이터 ( 문자열, 숫자 )
   3) 배열 ( JSON 불가 )
   4) null, true, false 사용 가능 ==> 랜더링 안됨.
     => 조건부 랜더링(*****)
       JSX 영역에서 자바스크립트 사용하기 위해서는 {} 사용해야 된다.
       예> { 변수명 && <p>hello</p> }  변수명이 true이면 <p>가 보이고 
                                            false이면 <p>가 안보임.
  ############################################
  실습   
      src_01_컴포넌트작성3_반환값종류
  ############################################
    
8. JSX

  1)개념
    - JSX ( Javascript XML)로서 UI 구현 담당.
    - JSX는 브라우저에서 보여지기전에 html로 바뀐다. ( tool chain이 변경해줌 )
      따라서 JSX는 그냥 브라우저에서 바로 볼수 없다. ( JSX는 비표준 문법 )

  2)특징
   - JSX는 반드시 종료태그가 있어야 된다. 
     예> html의 br태그는 종료태그가 없다. <br>
         JSX 에서는 <br/> 지정해야 된다.                               

   - JSX는 반드시 단 하나의 root태그가 있어야 된다. 일반적으로 <div> 대신에 <> 주로 사용된다.
     예> return(
           <>
	    <p></p>
            <p></p>
           </>
         )
   
    - JSX에서 자바스크립트 사용할 때는 반드시 {} 사용한다.
    - JSX에서 이벤트처리시 카멜표기법 사용해야 된다.
       예> <button onclick="">  안됨.
           <button onClick="">  됨.

    - JSX에서 css 설정하기 위해서 class 대신에 className 를 사용해야  된다.
       예> <button class="">  안됨.
           <button className="">  됨.

	  ==> class는 키워드이기 때문이다.

     - JSX에서 라벨 태그에 for 키워드 대신에 htmlFor 를 사용해야 된다.
       예> <label for="id">아이디    안됨.
            <input  name="id" />


	    <label htmlFor="id">아이디    됨.
            <input  name="id" />

      - JSX에서 style 속성으로 지정시  속성명의 -(하이픈) 대신에 카멜표기법을 사용해야 된다.
        중첩 {{}} 형식을 사용한다.
       예> <p style="font-size:'30px'">  안됨
           <p style={{fontSize:'30px'}}">   됨

      - JSX에서 주석문은  {/* 문장 */}
      - JSX 에서 image는 src/assets 폴더에 저장하고 import 해서 사용한다.

############################################
  실습   
	src_02_JSX
############################################

9. 리액트에서 사용 가능한 데이터 종류


   1) props (속성값) 
      - 변경불가 ( readonly ), option 이다.	 
      - 용도:부모컴포넌트에서  자식컴포넌트로 데이터 전달할 때 사용됨. 
            자식에게 JSON 형식으로 전달됨.
       예>
             // 부모
             function App(){
		return(
		   <Profile name="홍길동" age={20} />
		   <Profile />
		)
	     }

	     // 자식1	
	     function Profile(props){  // {name:"홍길동", age:20 }
		  const {name, age} = props;
	     }

	     // 자식2 - 객체분해할당 이용, default 값 지정 가능	
	     function Profile({name,age=20}){  // {name:"홍길동", age:20 }
		  
	     }
        
        - children 방식으로 JSX 전달
            // 부모
             function App(){
		return(
		   <Profile name="홍길동" age={20} >
		     몸체(문자열, JSX태그들)
		   </Profile>
		)
	     }
            
	    // 자식1	
	     function Profile(props){  // {name:"홍길동", age:20 , children:몸체}
		  const {name, age, children} = props;
	     }
	    // 자식2	
	     function Profile({name, age, children}){

	     }

	 정리: 부모에서 자식에게 데이터를 전달하는 방법 2가지
	      - 속성(attribute)이용
	      - children 이용

   2) state (상태값)
      - 변경가능 (read/write)
      - 용도: 컴포넌트에서 필요한 데이터중에서 변경이 필요한 데이터 처리시 사용됨.
      - 특징: state값이 변경되면 변경된 state값을 보여주기 위해서 자동 재랜더링된다. 

############################################
  실습  
	src_03_props01_기본
	src_03_props02_children
############################################

10. 이벤트 처리

   - 이벤트 핸들러(이벤트함수)는 함수 컴포넌트 안에서 정의 ( 중첩형태 )
   - 이벤트 핸들러지정시 카멜표기법을 사용한다.  예> onClick, onChange
   - 콜백형식 및 arrow 함수 방법으로 사용한다.

        function handleEvent(event){
	  event.preventDefault();	
	}

     예> onClick={handleEvent}
        onClick={()=>{handleEvent()}} 

    - 이벤트객체를 얻기 위해서 반드시 event 파라미터를 지정해야 된다.
    - 기본동작 방지는 반드시 event.preventDefault(); 만 가능하다. ( JS 처럼 return false 안됨 )
    - 부모에서 자식에게 이벤트함수를 전달해서 자식이 부모의 함수 호출이 가능하다. ==> 자식에서 부모에게 임의의 값을 전달 가능
############################################
  실습 
	src_04_이벤트처리1_기본
	src_04_이벤트처리2_자식에서부모함수호출
	src_04_이벤트처리3_form태그의자동submit방지
############################################

11. hook 개념

   1) 개요
    -클래스 컴포넌트에서만 사용했던 기능을 함수형 컴포넌트에서도 
    사용할 수 있게 지원해줌 ==> hook
    -함수형 컴포넌트 개발을 권장함

   2) 사용규칙
      - 반드시 react 함수 컴포넌트의 최상위에서만 사용 가능 ( 조건문,반복문 사용 불가 )
      - useXXX 형식으로 제공, 커스텀 hook 작성 가능
      - 여러 개 지정 하면 순차적으로 적용됨.

  3) 종류

     - useState : 상태(state) 관리
     - useEffect : 부수효과(side effect)
                   핵심기능과 무관한 기능처리에서 사용 ( 예> 서버연동, DOM 변경 )
                   스프링의 AOP 개념
     - useRef   : DOM 직접 접근
     - useContext : 전역 데이터 관리
     - useMemo  : 메모이제이션 기능 
                  계산량이 많은 함수를 기억해서 이전 연산값을 재활용한다. 
     - useCallback : 메모이제이션 기능 
                     함수를 재생성 방지

      - useReducer : ustState 업그레이드 버전
		 

12. useState hook

   1)개요
    -  컴포넌트에서 사용할 데이터중에서 변경 될 수 있는 데이터 처리시 사용됨. ( read/write 모두 가능 )
    -  state 값이 변경되면 자동으로 재랜더링 된다.
    - state값에 저장되는 데이터는 문자,숫자,배열,JSON 모두 가능
      주의할 점은 객체(배열,JSON)는 불변객체로 관리해야 된다.
      불변객체? 새로운 값을 덮어쓰는 방식이다. 일반적으로 객체분해할당 이용(****)
    
    - state 에 boolean 값을 지정할 때 권장방식은 함수형태로 지정한다.
       예> isFlag(boolean)=true;
          setXXX(!isFlag); //권장 안함
	  setXXX(isFlag=>!isFlag) // 권장
 
    - state를 setXXX 함수로 변경하는데 바로 적용 안됨. ==> 배치(스케쥴링) 형식으로 처리함.

   2) 사용방법

       가. import {useState} from 'react';
       나. 함수 컴포넌트 최상위에서 선언
           funtion Profile(){
	      // hook 사용 가능
	      const [변수, set변수명] = useState(초기값);
	
              function(){
	        // hook 사용불가
	      }

	   }
	다. state 수정
	     function handleEvent(){
		set변수명(새로운값);	
	     }
	     ==> 주의: 새로운값이 객체이면 새로운 객체를 만들어서 덮어쓰는 방식으로 수정해야 된다. ( 불변객체로 관리한다고 한다.)
	     ==> 자동으로 화면 재랜더링 됨.
	라. state 값 참조
	   jsx: {변수}

############################################
  실습 
   src_05_useState01_기본
   src_05_useState02_불변객체_배열	
   src_05_useState02_불변객체2_JSON
############################################

13. state 이용한 조건부 랜더링 

    1) if문
    2) 3항 연산자
    3) && 연산자 ( ***** )

############################################
  실습 
	src_05_useState03_조건부랜더링3가지방법
############################################

14. two-way binding 방법
    - state와 input 태그 같이 사용하는 경우에 적용하는 방법이다.
    - 반드시 onChange 에서 사용자 입력값으로 state 값을 변경하는 코드를 구현해야 된다.

############################################
  실습 src_05_useState04_input태그사용
      src_05_useState05_실습6
############################################


15. useRef

   1)용도
     - 실제 DOM 접근할 때 사용
       예) input의 focus 지정, DOM 크기 정보를 알고 싶은 경우
     - DOM이 아닌 일반값도 저장 가능
   
   2) 문법
      
       import {useRef} from 'react';

       const x = useRef();	

       아이디:<input ref={x} type='text' name="userid" />
      
       실제 참조: x.current 지정하면 input 태그를 참조할 수 있다.
       

    3) 특징
      - 저장 가능한 값은 DOM 및 일반 데이터이다.
      - 값이 변경되도 state 와 다르게 화면이 재랜더링 안된다.
        따라서 직접적으로 UI에 영향을 주지 않는다.

   
    4) 부모 컴포넌트에서 자식 컴포넌트 참조해서
       자식의 함수 호출
    
       예> function App(){
		return(
                  <Profile ref={x} name="홍길동"/>
		}
            }

          function Profile(){
	  
	     function open(){}
	  }


############################################
  실습 src_06_useRef01_state로input관리한경우_매번랜더링됨
      src_06_useRef02_ref로inpu관리한경우_매번랜더링안됨
      src_06_useRef03_부모에서자식함수호출_forwardRef_useImperativeHandle이용
      src_06_useRef04_modal창구현
############################################

16. Context API

    1)개요
     - 일반적으로 구현한 어플리케이션이 부모에서 자식으로 반복적으로 속성값(props)을 전달할 확률이 매우 높다.
        prop drilling 현상이라고 부른다.

    2) 해결
      - Context API 이용
      - 부모: createContext 이용해서 데이터 저장소에 저장.
        자식: useContext로 데이터 사용.


     3) 구현
      
         가. 부모 구현

	     import {useState,createContext} from 'react';

	     const UserContext = createContext(기본값);  // 변수명의 첫글자는 대문자. 컴포넌트로 사용됨.
	     
	     const [name, setName] = useState(기본값);

	     return(

               <UserContext.provider value={name}> // 전달하는 값 종류에 제한이 없다. ( 함수도 가능 )
                 <Profile />                 // 하위인 <Profile /> 및 그 자식들에서 context값 사용 가능
               </UserContext.provider >
	     }

	   
	 나. 자식(들) 구현
             import {useContext} from 'react';
	    
	      const username = useContext(UserContext);
	      console.log(username);
 
     4) 실습
      
         App ==> createContext 생성해서 값 저장
	   - Profile
	        - Greeting  ==> useContext 로 값 조회
